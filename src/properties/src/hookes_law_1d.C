//-----------------------------------------------------------------------bl-
//--------------------------------------------------------------------------
//
// GRINS - General Reacting Incompressible Navier-Stokes
//
// Copyright (C) 2014-2015 Paul T. Bauman, Roy H. Stogner
// Copyright (C) 2010-2013 The PECOS Development Team
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the Version 2.1 GNU Lesser General
// Public License as published by the Free Software Foundation.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc. 51 Franklin Street, Fifth Floor,
// Boston, MA  02110-1301  USA
//
//-----------------------------------------------------------------------el-

// This class
#include "grins/hookes_law_1d.h"

// GRINS
#include "grins/elasticity_tensor.h"

// libMesh
#include "libmesh/getpot.h"
#include "libmesh/tensor_value.h"

namespace GRINS
{
  HookesLaw1D::HookesLaw1D(const GetPot& input)
    : StressStrainLaw<HookesLaw1D>(),
    _E(0.0),
    _nu(0.0)
  {
    this->read_input_options(input);

    return;
  }

  HookesLaw1D::~HookesLaw1D()
  {
    return;
  }

  void HookesLaw1D::read_input_options(const GetPot& input)
  {
    // We'd better have either Lam\'{e} constants or E and nu
    if( ( !input.have_variable("Physics/HookesLaw/lambda") ||
          !input.have_variable("Physics/HookesLaw/mu") ) &&
        ( !input.have_variable("Physics/HookesLaw/E") ||
          !input.have_variable("Physics/HookesLaw/nu") ) )
      {
        std::cerr << "Error: Must specify either Lame constants lambda and mu or" << std::endl
                  << "       Young's modulus and Poisson's ratio." << std::endl;
        libmesh_error();
      }

    if( input.have_variable("Physics/HookesLaw/E") )
      _E = input("Physics/HookesLaw/E", 0.0 );

    if( input.have_variable("Physics/HookesLaw/nu") )
      _nu = input("Physics/HookesLaw/nu", 0.0 );

    if( input.have_variable("Physics/HookesLaw/lambda") &&
        input.have_variable("Physics/HookesLaw/mu") )
      {
        libMesh::Real lambda  = input("Physics/HookesLaw/lambda", 0.0);
        libMesh::Real mu = input("Physics/HookesLaw/mu", 0.0);
        _E  = mu*(3*lambda + 2*mu)/(lambda+mu);
        _nu = lambda/(2*(lambda+mu));
      }

    return;
  }

  void HookesLaw1D::compute_stress_imp( unsigned int /*dim*/,
                                        const libMesh::TensorValue<libMesh::Real>& g_contra,
                                        const libMesh::TensorValue<libMesh::Real>& g_cov,
                                        const libMesh::TensorValue<libMesh::Real>& /*G_contra*/,
                                        const libMesh::TensorValue<libMesh::Real>& G_cov,
                                        libMesh::TensorValue<libMesh::Real>& stress )
  {
    stress.zero();

    libMesh::Real strain = 0.5*(G_cov(0,0) - g_cov(0,0));

    stress(0,0) = (this->_E)*g_contra(0,0)*g_contra(0,0)*strain;

    return;
  }

  void HookesLaw1D::compute_stress_and_elasticity_imp( unsigned int dim,
                                                       const libMesh::TensorValue<libMesh::Real>& g_contra,
                                                       const libMesh::TensorValue<libMesh::Real>& g_cov,
                                                       const libMesh::TensorValue<libMesh::Real>& G_contra,
                                                       const libMesh::TensorValue<libMesh::Real>& G_cov,
                                                       libMesh::TensorValue<libMesh::Real>& stress,
                                                       ElasticityTensor& C)
  {
    this->compute_stress_imp(dim,g_contra,g_cov,G_contra,G_cov,stress);

    C(0,0,0,0) = this->_E*g_contra(0,0)*g_contra(0,0);

    return;
  }

  libMesh::Real HookesLaw1D::compute_33_stress_imp( const libMesh::TensorValue<libMesh::Real>& /*g_contra*/,
                                                    const libMesh::TensorValue<libMesh::Real>& /*g_cov*/,
                                                    const libMesh::TensorValue<libMesh::Real>& /*G_contra*/,
                                                    const libMesh::TensorValue<libMesh::Real>& /*G_cov*/ )
  {
    libmesh_not_implemented();

    return 0.0;
  }

} // end namespace GRINS
