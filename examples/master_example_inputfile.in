# This master example input file is for reference on specifying
# various input parameters to GRINS. The GetPot parsing library
# is used to parse the input files. Documentation about GetPot
# can be found here:
# http://getpot.sourceforge.net/documentation-index.html
# The Doxygen documentation can be found here:
# http://libmesh.github.io/doxygen/classGETPOT__NAMESPACE_1_1GetPot.html
#
# Concrete examples of usage can be found in both the examples
# directories and in test/input_files (which are the input_files for
# the tests in the testing suite).
#
# We heavily use GetPots sectioning system, particularly nested
# sections. Discussion of this can be found here:
# http://getpot.sourceforge.net/node13.html
# Below we give examples of different uses for the various sections
# GRINS uses. Note that the section names must be unique. We provide
# multiple example usages of the sections below, but you must only use
# one. E.g. we illustrate the different uses of [Mesh] below, but
# there must only be one instance of the [Mesh] section in the input
# file used.
#
# GRINS uses GetPot's UFO capability so that if there are variables in the
# input file that are unused during your program, GRINS will throw
# an error. This is to reduce the chance of errors in the input
# file specification.
#
# In the default grins binary, as well as in any libgrins.so
# application that so chooses, it is possible to override input-file
# options using command-line options.  For example, running
# $ grins input.in Mesh/class=parallel
# will try to use a DistributedMesh regardless of what the value of
# Mesh/class is in input.in
#
# The primary sections are:
#    [Mesh] - all options related to the mesh used in the simulation
#    [Materials] - all material property specifications
#    [Strategies] - options related to things like adaptive time
#                   stepping and AMR
#    [SolverOptions] - all options related to the (non)linear solver,
#                      time stepping, etc.
#    [BoundaryConditions] - Boundary condition specification
#    [Variables] - Variable and finite element space specification


# The block below is an example of using basic mesh generation
# utilities in libMesh to construct a mesh. An example of reading
# a mesh from a file is given below. Use only ONE of these sections.
[Mesh]

   # Specify whether you want to use libMesh::SerialMesh
   # or libMesh::ParallelMesh.
   # Optional. Defaults to libMesh::Mesh (which depends on the
   #           libMesh build.
   # Acceptable values: serial, parallel
   class = 'serial'

   # Since we are generating a mesh, all the generation
   # options will be in the Generation subsection.
   [./Generation]

      # Specify the dimension of the mesh to build.
      # Mandatory.
      # Acceptable values: 1, 2, 3
      dimension = '3'

      # Specify the number of elements in the {x,y,z}-direction
      # Mandatory:
      #    dimension = 1: n_elems_x
      #    dimension = 2: n_elems_x, n_elems_y
      #    dimension = 3: n_elems_x, n_elems_y, n_elems_z
      # Acceptable values: positive integer
      n_elems_x = '10'
      n_elems_y = '10'
      n_elems_z = '10'

      # Specify the spatial extents in the {x,y,z}-direction
      # Optional. {x,y,z}_min defaults to 0.0, {x,y,z}_max defaults to 1.0
      # Acceptable values: Real number
      x_min = '0.0'
      x_max = '1.0'

      y_min = '0.0'
      y_max = '1.0'

      z_min = '0.0'
      z_max = '1.0'

      # Specify the geometric element type to use in the mesh
      # Optional:
      #    dimension = 1, defaults to EDGE3
      #    dimension = 2, defaults to TRI6
      #    dimension = 3, defaults to TET10
      # Acceptable values:
      #    See enum libMesh::ElemType at libmesh.github.io/doxygen/index.html
      element_type = 'QUAD4'

[]


# The block below is an example of reading a mesh from a given
# mesh file. An example of generating  a mesh using libMesh's basic
# utilities is given above. Use only ONE of these sections.
[Mesh]

   # Specify whether you want to use libMesh::SerialMesh
   # or libMesh::ParallelMesh.
   # Optional. Defaults to libMesh::Mesh (which depends on the
   #           libMesh build.
   # Acceptable values: serial, parallel
   class = 'serial'

   # Since we are reading a mesh, all read options
   # go in the Read subsection.
   [./Read]

       # Specify filename to be read. This can be a Unix path.
       # libMesh decides which reader to use based on the suffix.
       # Mandatory.
       filename = 'meshfile.exo'

[]

# The block below illustrates two optional sections.
# They can be used together, where redistribution will be done
# before refinement, and can be used in conjunction with mesh
# generation or reading a mesh from a file.
[Mesh]

   # Options related to doing input-based refinement. Adaptive refinement
   # is controlled in the in solver section.
   [./Refinement]

       # Specify the number of uniform refinements to perform
       # Optional. Defaults to 0.
       uniformly_refine = '1'

       # Specify a function of (x,y,z) suitable for libMesh::ParsedFunction.
       # This function should return the number of refinements to be performed
       # as a function of (x,y,z); element centroids are used to evaluate the
       # spatial locations. Value from function will automatically be converted to int.
       # If the value is less than zero, no refinements will be done.
       locally_h_refine = '(9-x)/4.5+(abs(y)<.2)'

   # Options related to input-based mesh redistribution
   [../Redistribution]

       # Specify a function of (x,y,z) suitable for libMesh::ParsedFunction.
       # Nodal (x,y,z) locations will be mapped according to the function given.
       # See libMesh::MeshTools::Modification::redistribute. Note each mapping component
       # is in separated by {}. In the example given, the x-components of the node will be
       # mapped by x+x*(x-30)/30, the y-components of the nodes will by scaled by a factor of 2,
       # and z-components remain unchanged.
       function = '{x+x*(x-30)/30}{y*2}{z}'

[]

# The block below illustrates specifying properties for different
# materials to be used by a Physics. Many different materials can be
# specified within the [Materials] section. The name of the material
# is arbitrary and is meant to be referenced by the "material" input
# specifier within each Physics input section. Listed below are the various
# material properties currently understood by various Physics within
# GRINS. Note that if a material property is not used by a Physics,
# it is not needed it will be an unused variable (causing an error at runtime).
[Materials]

  # Arbitrary material name. Here we describe input parameters related
  # to the Cantera thermochemistry library. These are used for reacting
  # flow Physics.
  [./CanteraMaterial]
     [./GasMixture]
        # Notify that we're using Cantera
        thermochemistry_library = 'cantera'

        [./Cantera]
           # Specify the mixture to be used. This is the "mixture" or "phase"
           # given in the chemical_data file. The user must set this
           # since the Cantera data file may contain more than one mixture.
           gas_mixture = 'air4sp'

           # Path to file containing thermochemical and transport data.
           # This is the only file Cantera will look for so all data
           # must be present in the Cantera XML format.
           # You may wish to consider looking at Cantera's .cti format
           # and then using Cantera-deployed tools to convert to .xml format.
           # If you have a ChemKin file, Cantera deploys a ck2cti tool
           # to convert to cti, then you can convert to XML.
           chemical_data = 'datafile.xml'
        [../]
     [../]
   [../]

   # Arbitrary material name. Here we describe input parameters related
   # to the Antioch thermochemistry library. These are used for reacting
   # flow Physics. Note that units here *must* be SI.
   # Although we support ASCII input to Antioch, XML format is much preferred.
   # The parsing type is determined by the suffix on the chemical data file:
   # .dat --> ASCII
   # .xml --> XML
   # .chemkin --> CHEMKIN (not yet supported)
   [./AntiochMaterial]
      [./GasMixture]
         # Notify that we're using Antioch
         thermochemistry_library = 'antioch'

         # Antioch model specification
         [./Antioch]

           # For XML, we assume you have all kinetics, thermo, and transport data
           # (modulo Blotter or Sutherland data, which are specified in separate files).
           # For the thermo, we will query the XML file to determine whether it's NASA7
           # or NASA9. NASA models are always used for the chemistry and if
           # thermo_model (see below) is ideal_gas, then that NASA model will
           # also be used there.
           chemical_data = 'datafile.xml'

           # Specify the mixture to be used. This is the "mixture" or "phase"
           # given in the chemical_data file if it's an xml file.
           # The user must set this when using an XML file since the data file
           # may contain more than one mixture. If using ASCII parsing, this
           # variable is not used and not needed.
           gas_mixture = 'air4sp'

           
           # The type of transport model. Currently accepted values
           # are: constant, mixture_averaged
           transport_model = 'constant'

           # Model used for computing thermodynamic quantities.
           # Currently accepted values are: ideal_gas, stat_mech
           #
           # ideal_gas corresponds to assuming electronic states are not populated
           # and vibrational are partially populated and computed by taking the NASA
           # curve fit value for the total and subtracting the translational and
           # vibrational energy. This is a common model in combustion applications.
           #
           # stat_mech will use statistical mechanics relations to compute translational,
           # rotational, vibrational, and electronic energies. Note these strongly depend
           # on having the correct modes/degenercies for vibrational and electronic states
           # for each species.
           thermo_model = 'ideal_gas'

           # Model used for computing viscosity.
           # Currently accepted values are:
           #   constant (only valid with transport_model = constant)
           #   blottner (transport_model = mixture_averaged, requires blottner_data)
           #   sutherland (transport_model = mixture_averaged, requires sutherland_data),
           #   kinetics_theory (* transport_model = mixture_averaged,
           #                    * requires transport_data if using ASCII parsing or have data in XML file
           #                      if using XML parsing
           #                    * requires thermal_conductivity_model and mass_diffusivity_model
           #                      to  be kinetics_theory)
           #
           # For viscosity_model = 'constant', the viscosity value
           # will be parsed from [Materials/material-name/Viscosity/value]
           viscosity_model = 'constant'

           # Model used for computing thermal conductivity.
           # Currently accepted values are:
           #   constant (only valid with transport_model = constant)
           #   constant_prandtl
           #   eucken (transport_model = mixture_averaged, requires thermo_model = stat_mech)
           #   kinetics_theory (* transport_model = mixture_averaged,
           #                    * requires transport_data if using ASCII parsing or have data in XML file
           #                      if using XML parsing 
           #                    * requires viscosity_model and mass_diffusivity_model
           #                      to be kinetics_theory)
           #
           # For thermal_conductivity_model = 'constant', the conductivity value
           # will be parsed from [Materials/material-name/ThermalConductivity/value]
           #
           # For thermal_conductivity_model = 'constant_prandtl', the
           # Prandtl number will be parsed from [Materials/material-name/PrandtlNumber/value]
           thermal_conductivity_model = 'constant'

           # Model used for computing mass diffusivity
           # Currently accepted values are:
           #   constant_lewis (transport_model = mixture_averaged, constant)
           #   kinetics_theory (* transport_model = mixture_averaged,
           #                    * requires transport_data if using ASCII parsing or have data in XML file
           #                      if using XML parsing
           #                    * requires viscosity_model and thermal_conductivity_model
           #                      to be kinetics_theory)
           #
           # For  mass_diffusivity_model = 'constant_lewis', the lewis number
           # will be parsed from [Materials/material-name/LewisNumber/value]
           mass_diffusivity_model = 'constant_lewis'


           # All of the following are datafiles used by Antioch. For
           # values of 'default' (omission of these input options is
           # equivalent to a value of 'default'), the default file installed with
           # Antioch will be used. You may use your own datafile by
           # setting the value to the fullpath of the datafile you
           # wish to use.
           species_data = 'default'
           vibration_data = 'default'
           electronic_data = 'default'
           cea_data = 'default'
           transport_data = 'default'
           sutherland_data = 'default'
           blottner_data = 'default'

           # Antioch reaction rates are evaluated at the temperature
           # of the flow field.  This can result in NaNs if "ringing"
           # near sharp features has created negative temperatures
           # anywhere in the flow field.  Users can specify a minimum
           # temperature at which to evaluate reaction rates in order
           # to improve stability (at the cost of reduced
           # differentiability and Newton convergence rate in those
           # cases)
           minimum_T = 10

           # Antioch reaction rates are evaluated using the densities
           # computed from the flow field.  This can result in NaNs or
           # instabilities if "ringing" near sharp features has
           # created negative densities for any species.  If users
           # enable the clip_negative_rho option, then species with
           # negative densities are treated as if they had zero
           # density when computing reaction rates.
           clip_negative_rho = true


   [../../Viscosity]
      value = '1.0e-5' # Units *must* be SI in this case.

   [../ThermalConductivity]
      value = '0.02' # Units *must* be SI in this case.

   [../LewisNumber]
      value = '1.4'

   # Arbitrary Material name. We list all other possible material
   # properties here. For these generic cases, i.e. non-reacting,
   # there is no limitation on the units used. However, it is up to
   # the user to be self-consistent.
   [../../GenericMaterial]

      [./ThermodynamicPressure]
         value = '101325'

      [../ReferenceTemperature]
         value = '600'

      [../GasConstant]
         value = '287.0'

      [../ThermalConductivity]
         model = 'constant'
         value = '.041801'

      [../Viscosity]
         # Accepted values: constant, spalartallmaras
         #
         # spalartallmaras only valid when used with SpalartAllmaras
         # Physics. Also requires specification of turb_visc_model = 'constant'
         model = 'constant'

         value = '2.95456e-5'

      [../SpecificHeat]
         model = 'constant'
         value = '1004.5'

      [../Density]
         value = '1.0'

      [../MembraneThickness]
         value = '0.05'

      [../CrossSectionalArea]
         value = '0.1'


      [../StressStrainLaw]
         # Here we can specify the stress-strain law for an elastic material.
         #  Currently accepted values are:
         #     incompressible_hyperelasticity
         #     hookes_law
         model = 'incompressible_hyperelasticity'

         # If the stress-strain model is
         # incompressible_hyperelasticity, then the strain_energy
         # option controls what strain energy function is used.
         # Currently accepted values are:
         #   mooney_rivlin
         strain_energy = 'mooney_rivlin'

         # Parameters for the Mooney-Rivlin material
         [./MooneyRivlin]
            C1 = '24'
            C2 = '3.0'

         # Parameters for Hookes law. Used if
         # [Materials/material-name/StressStrainLaw] is set to hookes_law
         [../HookesLaw]
            # Youngs modulus
            E = '10000'

            # Poisson's ratio
            nu = '0.3'
[]


# The block below illustrates specifying options for the solver.
# Solvers are things like linear solver, nonlinear solver, and
# time stepping.
[SolverOptions]

   # Set the solver_type to be used for the simulation.
   # For the grins native solvers, this is currently optional,
   # since transience and AMR is detected from other options.
   # But the user may explictly set this option. Additionally,
   # if the user wishes to deploy their own solver, they will
   # set the name of the solver, if it's to be used in the
   # simulation, here.
   #
   # Current valid options are:
   #   grins_steady_solver
   #   grins_unsteady_solver
   #   grins_steady_mesh_adaptive_solver
   #   grins_unsteady_mesh_adaptive_solver
   solver_type = 'grins_steady_solver'

   # Options related for time stepping algorithms
   [./TimeStepping]

      # This is the algorithm for time-stepping. Time stepping
      # is triggered by setting this option, so if it is not
      # set, then an unsteady algorithm will not be selected.
      #
      # Current valid options are:
      #   libmesh_euler_solver
      #   libmesh_euler2_solver
      solver_type = 'libmesh_euler_solver'

      # This sets the time step size. There is no default.
      # If using an unsteady algorithm, this option must be
      # set or an error occurs.
      delta_t = '1.0'

      # This sets the number of time steps to take. There is no default.
      # If using an unsteady algorithm, this option must be
      # set or an error occurs.
      n_timesteps = '10'


      # Set the theta value for the theta methods.
      # This option is only relevant for the following solver_types:
      #    libmesh_euler_solver
      #    libmesh_euler2_solver
      #
      # The value of theta should be between 0.0 and 1.0
      # The default value if not specified is theta = '0.5'
      theta = '1.0'
[]

# The block below illustrates specifying options for "strategies"
# that augment the solution process, such as mesh adaptivity.
[Strategies]

   # These options relate to computing error estimates in the solution
   # and error indicators that drive adaptive mesh refinement. Currently,
   # these options are only relevant with mesh adaptivity; in the future
   # these will be enabled even for non-adaptive solutions. See the
   # ErrorEstimatorOptions object for the full set of options.
   [./ErrorEstimation]

       # The type of error estimator to be used. Defaults to none.
       # Valid selections include: kelly
       #                           patch_recovery
       #                           adjoint_residual
       #                           adjoint_refinement
       #
       # The adjoint* estimators are currently only supported
       # for steady solvers. They will trigger the solution
       # of the adjoint problem.
       estimator_type = 'none'

   # These options relate to enabling adaptive time stepping.
   # Currently, we use the libMesh::TwoStepSolver for this.
   # See AdaptiveTimeSteppingOptions object for the full list of options.
   [../AdaptiveTimeStepping]

      # The target error tolerance for the current time step
      # Defaults to 0.0. A positive value will trigger the use
      # of adaptive timestepping.
      target_tolerance = '0.0'

   # These options relate to performing mesh adaptivity during the
   # solution process. See the MeshAdaptivityOptions object for the
   # full list of options.
   [../MeshAdaptivity]

       # Triggers the use of mesh adaptivity in the solution process.
       mesh_adaptive = 'false'

       # Strategy used for refining/coarsening mesh. Defaults to elem_fraction.
       # Valid options are: elem_fraction
       #                    error_tolerance
       #                    nelem_target
       #                    error_fraction
       #                    mean_std_dev
       refinement_strategy = 'elem_fraction'

       # The number of adaptive refinement/coarsening steps to perform.
       # Defaults to 0.
       max_refinement_steps = '0'

   # These options relate to augmenting the assembly process.
   [../Assembly]

      # This will increase the quadrature order, by
      # the supplied, during the assembly process.
      # Defaults to 0 (no extra quadrature).
      extra_quadrature_order = '0'

   # These options relate to the solution of the adjoint problem.
   [../Adjoint]

      # Manually trigger the solution of the adjoint problem.
      # Currently only applies to steady solvers.
      do_adjoint_solve = 'false'
[]


# The block below illustrates the use of the boundary conditions
# block. Generally, the boundary conditions are tied to the
# [Variables]. We require that boundary conditions be specified
# for every boundary id and for every non-constraint Variable. There are two
# exceptions for specifying for every variable: axisymmetric and
# periodic. In either of those two cases, that boundary condition will
# apply to all variables and the appropriate boundary condition will be
# used for each variable automatically for non-GenericVariables.
[BoundaryConditions]

   # These are the boundary ids present in the mesh. All the bc_ids
   # specified must be in the mesh and all the boundary ids in the mesh
   # should be present in bc_ids. If not, an error will be thrown.
   # The ':' delimiter may be used to "lump" together boundary ids if
   # all the boundary ids in the set have the same boundary conditions for
   # each variable. In this case, there are 5 sets of boundary ids.
   bc_ids = '0 1 2:3 4:5:6 7'

   # This associates a name to each set of the boundary ids given in
   # bc_ids variable. These are arbitrary with the only requirement
   # that they match with the section names below. GRINS only parses
   # these and makes no behavior determination other than searching
   # for sections below.  For example, naming the boundary "Periodic"
   # does not imply that periodic boundary conditions will be
   # used (that is controlled by the "type" variable below). Because
   # there were 5 sets of bc_ids, there must be 5 boundary names in
   # bc_id_name_map.
   bc_id_name_map = 'MyBoundary Hot Periodic Cold Axisymmetric'

   # For each of the boundary names in bc_id_name_map, there must be a
   # corresponding subsection of [BoundaryConditions]. All of the
   # boundary condition types specified in each boundary section will
   # apply to boundary ids associated with the boundary name. Every
   # Variable must have a boundary condition specified or an error
   # will be thrown.
   #
   # We illustrate all
   # the options in this section, except for axisymmetric and periodic
   # which are discussed below. We just note the presence of "Hot"
   # and "Cold" below and don't show options, but they would need to
   # be filled in analogously.
   [./MyBoundary]

      # For per-variable boundary condition specification, there must
      # be a variable section for each corresponding variable in the
      # [Variables] section. We illustrate several variables here and
      # note which have special types.
      #
      # Each section must have a 'type' specification. The currently
      # known "general" types are:
      #
      #  constant_dirichlet - Dirichlet boundary conditions specified
      #                       by a fixed real number.
      #
      #  parsed_dirichlet   - Dirichlet boundary conditions specified
      #                       by a parsed expression that can be a
      #                       function of (x,y,z,t), where x,y,z are
      #                       spatial coordinates and t is time.
      #
      #  parsed_fem_dirichlet - Dirichlet boundary condition specified
      #                         by a parsed expression that can be
      #                         function of solution variables.
      #
      #  homogeneous_dirichlet - Zero-valued Dirichlet boundary conditions
      #
      #  parsed_neumann - Analogous to parsed_dirichlet except this
      #                   will specify Neumann boundary conditions
      #                   for the variable.
      #
      #  parsed_fem_neumann - Analogous to parsed_fem_dirichlet except this
      #                       will specify Neumann boundary conditions
      #                       for the variable.  Note that, currently,
      #                       we do not automatically differentiate
      #                       the expression, nor are there input
      #                       variables for the derivatives, so this
      #                       option will require the use of
      #                       'use_numerical_jacobians only = true in
      #                       the solver options section.
      #
      #  homogeneous_neumann - "Do nothing" natural boundary conditions.
      #
      # For each of the constant/parsed Dirichlet types, the value is set by
      # the variable name. See below. Furthermore, for variable
      # components that are *not* specified, it is assumed they are
      # zero. However, there must be at least one component specified
      # or an error will be thrown. For the homogeneous types, no
      # components should be specified: all components will be set to
      # zero.
      #
      # For each of the non-homogeneous neumann types, the variable
      # "normal_flux" will specify the value. For Variables with
      # multiple components, e.g. Displacement, the number of
      # components of normal_flux should match the number of Variable
      # components. E.g. for two-dimensional displacement fields, the
      # normal_flux should be a two-dimensional vector.
      #
      # There are also symmetry types:
      #
      #    yz_symmetry - symmetry about yz-plane; x-component is
      #                  pinned to 0
      #    xz_symmetry - symmetry about xz-plane; y-component is
      #                  pinned to 0
      #    xy_symmetry - symmetry about xy-plane; z-component is
      #                  pinned to 0
      #    roller_x - Can "roll" in x-direction; y and z-component
      #               pinned to 0
      #    roller_y - Can "roll" in y-direction; x and z-component
      #               pinned to 0
      #    roller_z - Can "roll" in z-direction; x and y-component
      #               pinned to 0
      #
      # One may specify multiple 'types' for a given
      # variable. E.g. for a Displacement variable, only may have a
      # combined roller and traction boundary condition:
      # type = 'roller_x parsed_traction'


      [./Velocity]
         # In this case, the velocity is a Dirichlet boundary condition and
         # we've set the u-component to '1.0'. All other velocity
         # components will be zero since they have not been
         # specified. One could, of course, explicitly set them to zero
         # for added clarity.
         #
         # Velocity variables also accept type = 'no_slip', which is
         # functionally identical to 'homogeneous_dirichlet'
         type = 'constant_dirichlet'
         u = '1.0'
      [../]
      [./Temperature]
         # Temperature variables additionally admit 'type = isothermal', which is
         # functionally identical to constant_dirichlet. Additionally, one
         # can set type = 'adiabatic', which is functionally identical
         # to homogeneous_neumann.
         type = 'isothermal'
         T = '100'
      [../]
      [./Displacement]
         # Displacement variables additionally admit 'type = pinned',
         # which is functionally identical to
         # homogeneous_dirichlet. Furthermore, additional Neumann types
         # for Displacement variables include parsed_traction,
         # parsed_fem_traction, and constant_traction; these are
         # functionally identical to parsed_neumann, parsed_fem_neumann,
         # and parsed_neumann, respectively.
         type = 'parsed_neumann
         normal_flux = 'cos(pi*x) 0.0'
      [../]
      [./SpeciesMassFractions]
         # SpeciesMassFractions are somewhat special since the
         # variables are tied to species name. The names of each
         # variable correspond to <prefix>_<species name>, where prefix
         # is the prefix given in the [Variables/SpeciesMassFractions]
         # section and the species name corresponds to the names of
         # the species in the species list.
         #
         # SpeciesMassFractions additionally admit 'type =
         # mole_fractions' for Dirichlet boundary conditions. The
         # specified value for the species will be interpreted as mole
         # fractions and then internally converted to mass fractions.
         # For type = mole_fractions each non-zero component should be
         # specified as "X_<species name>", e.g. 'X_N2 = 0.1' would
         # specify a 0.1 mole fraction for the N2 species. As with
         # other dirichlet boundary conditions, any species not specified
         # will be assumed to be zero (but there must be at least
         # one). Additionally, the specified values must sum to 1.
         #
         # There are also special Neumann boundary condition types,
         # namely "type = gas_recombination_catalytic_wall" and
         # type = "gas_solid_catalytic_wall". Each of these
         # corresponds to a catalytic wall boundary condition
         # according to a particular form. We show examples of both
         # below.

         # Gas recombination catalytic walls correspond to the special
         # case of recombining species, with no other surface
         # reactions involving those species. For example,
         # N+N->N2. We're assuming that N2 is only formed by the
         # recombining N. So, for this type of catalytic wall, no
         # other surface reactions may involve N or N2.
         # The reaction is specified as catalytic_reaction = 'N->N2'
         # where the species to the left of '->' is the reactant
         # and the species to the right of '->' is the product.
         # The catalycity model is specified by the catalycity_type.
         # Currently implemented catalycities include: constant,
         # arrhenius, and power. Each catalycity model has parameters
         # that must be specified. We show examples of each below.
         type = 'gas_recombination_catalytic_wall'
         catalytic_reaction = 'N->N2'

         catalycity_type = 'constant'
         [./ConstantCatalycity]
            gamma = '0.001'
         [../]

         catalycity_type = 'arrhenius'
         [./ArrheniusCatalycity]
            gamma0 = '0.001'
            Ta = '300'
         [../]

         catalycity_type = 'power'
         [./PowerLawCatalycity]
            gamma0 = '0.001'
            Tref = '300'
            alpha = '20'
         [../]


         # Gas-solid catalytic walls correspond to the special
         # case of gaseous species reacting with a solid species
         # to form a product. Again, it is assumed the gaseous species
         # and the product are not part of other surface chemistry
         # reactions. For example, take  N+C(s)->CN. We're assuming
         # that N and C form CN so N and C
         # should not be involved in other surface reactions.
         # The reaction is specified as catalytic_reaction =
         # 'N+C(s)->CN' The (s) should immediately follow the solid
         # species name; if there is no (s), an error will be thrown.
         # We could also write 'C(s)+N->CN'; this would
         # parsed identically the previous case. The catalycity models
         # are specified as before.
         type = 'gas_solid_catalytic_wall'
         catalytic_reaction = 'N+C(s)->CN'

      [../]
      [./GenericVariable:Physics]
         type = 'parsed_fem_dirichlet'
         u = 'u^2'
      [../]
      [./TurbulentViscosity]
         type = 'homogeneous_neumann'
      [../]
   [../]

   [./Hot]
      ...
   [../]

   [./Cold]
      ...
   [../]

   # type = 'axisymmetric' is special in that you do not need to
   # specify 'axisymmetric' for every Variable. Instead, GRINS will
   # apply appropriate axisymmetric boundary conditions to each
   # variable. The only exception is "GenericVariable" for which an
   # error will be thrown, since there's no physical context to know
   # what the correct axisymmetric boundary condition is.
   [./Axisymmetric]
      type = 'axisymmetric'
   [../]

   # type = 'periodic' is special in that you do not need to
   # specify 'periodic' for every Variable. Instead, GRINS will
   # apply appropriate periodic boundary conditions, using libMesh.
   # Note the corresponding bc_id set can have *only* two boundary ids
   # in it. If there are multiple sets of periodic boundaries, they
   # need to each be contained in there own bc_id set/boundary name.
   # Furthermore, there are 3 additional variables that must be
   # specified in this section. The first 2 are the master and slave
   # ids. These must match the two boundary ids in the bc_id set for
   # this boundary. Which is master and slave depends on the
   # boundary_offset. The boundary_offset is the vector displacement
   # between the two periodic boundaries. The vector is the
   # displacement from the master boundary to the slave boundary. So,
   # in the case, we're saying boundary 3 is offset from boundary 2 in
   # y-direction by 1.0 units.
   [./Periodic]
      type = 'periodic
      master_id = '2'
      slave_id = '3'
      boundary_offset = '0.0 1.0 0.0'
   [../]


[]

# The block below illustrates the use of the variables
# block. The variables are one of the most central concepts
# in the input file. The boundary conditions, initial conditions,
# and Physics will all reference the Variables section to varying
# degrees. There are two schema for Variable naming: the first is
# that the user can arbitrarily set the variable names, but then
# must set the "type"; the second is simply making the variable name
# one of the understood types and then the type specification is
# not needed.
#
# The type is used internally for things like axisymmetric boundary conditions.
# For each of the variables, the arguments "names" and "order" are
# always required. Additionally, "fe_family" is required for
# non-SCALAR variables.
#
# Variables also support restriction to subdomains. The user can
# set enabled_subdomains = '1 2 3' where 1 2 3 are the subdomain ids
# to which the variables will be restricted. If the enabled_subdomains argument
# is not present, it is assumed the variable is active on all
# subdomains. Note that any Physics that uses a subdomain restricted
# variable must be active on an inclusive subset of the subdomains
# to which the variable is restricted.
[Variables]

   # Here, the variable name is "MassFracs" whose type is
   # SpeciesMassFractions. For SpeciesMassFractions types,
   # the "names" argument is a prefix for the species names
   # so that the each of the corresponding variables will be
   # named, in this case, w_<species name> in the System.
   # This is why the "material" argument is also required for
   # SpeciesMassFractions variables: the species information
   # is parsed from the material.
   [./MassFracs]
      type = 'SpeciesMassFractions'
      names = 'w_'
      fe_family = 'LAGRANGE'
      order = 'SECOND'
      material = '2SpeciesNGas'
   [../]

   # Velocity is a variable type, so we don't need to specify the
   # type. Note that Velocity has multiple components and that
   # the number of components in the names argument will dictate
   # the dimensionality of the Velocity part. E.g. in this case, there
   # are two components so the velocity part of the problem will be
   # two-dimensional. Also note that all components will have the
   # same fe_family and order. Although not done here, we recommend
   # a naming scheme analogous to "Vx Vy Vz" --- the x/y/z suffix
   # will trigger a proper vector treatment in ParaView.
   # Here, the Velocity is restricted to subdomain 1.
   [./Velocity]
      names = 'u v'
      fe_family = 'LAGRANGE'
      order = 'SECOND'
      enabled_subdomains = '1'
   [../]

   # Pressure is a variable type, so we don't need to specify the
   # type. It should only have one component in names.
   [./Pressure]
      names = 'p'
      fe_family = 'LAGRANGE'
      order = 'FIRST'
   [../]

   # Temperature is a variable type, so we don't need to specify the
   # type. It should only have one component in names.
   [./Temperature]
      names = 'T'
      fe_family = 'LAGRANGE'
      order = 'SECOND'

      # We can add user constraints to variables.  Here we add a
      # ConstrainedPoints subsection which pins the temperature at two
      # edge nodes to equal half the temperature at the opposing edge
      # plus a 100K offset.
      [./ConstrainedPoints]
         [./FirstEdgeNode]
           constraint_location = '0.2 0 0'
           constraining_points_x = '0.2'
           constraining_points_y = '1.0'
           constraining_points_z = '0'
           constraining_points_coeff = '0.5'
           constraining_points_var = 'T'
           constraint_rhs = '100'

           # This might need to overwrite an existing Dirichlet
           # constraint on the boundary
           forbid_overwrite = false
         [../]
         [./SecondEdgeNode]
           constraint_location = '0.8 0 0'
           constraining_points_x = '0.8'
           constraining_points_y = '1.0'
           constraining_points_z = '0'
           constraining_points_coeff = '0.5'
           constraining_points_var = 'T'
           constraint_rhs = '100'
           forbid_overwrite = false
         [../]
      [../]
   [../]

   # Temperature is a variable type, so we don't need to specify the
   # type. It should only have one component in names. ThermoPressure
   # is a ScalarVariable type, so we do not specify the fe_family.
   [./ThermoPressure]
      names = 'p0'
      order = 'FIRST'
   [../]

   # TurbineVar is an arbitrary name, so we've specified the type.
   # Since the type is ScalarVariable, we do not specify the fe_family.
   [./TurbineVar]
      type = 'ScalarVariable'
      names = 'fan_speed'
      order = 'FIRST'
   [../]

   # Displacement is a variable type, so we don't need to specify the
   # type. Note that Displacement has multiple components and that
   # the number of components in the names argument will dictate
   # the dimensionality of the Displacement part. E.g. in this case, there
   # are three components so the displacement part of the problem will be
   # three-dimensional. Also note that all components will have the
   # same fe_family and order. Here, we've used the recommended vector
   # naming scheme so that "U" will show up as a vector variable in ParaView.
   [./Displacement]
      names = 'Ux Uy Uz'
      fe_family = 'LAGRANGE'
      order = 'FIRST'
   [../]
[]
